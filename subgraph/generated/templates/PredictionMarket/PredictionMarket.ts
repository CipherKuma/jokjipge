// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class BetPlaced extends ethereum.Event {
  get params(): BetPlaced__Params {
    return new BetPlaced__Params(this);
  }
}

export class BetPlaced__Params {
  _event: BetPlaced;

  constructor(event: BetPlaced) {
    this._event = event;
  }

  get bettor(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get outcome(): i32 {
    return this._event.parameters[1].value.toI32();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get shares(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Claimed extends ethereum.Event {
  get params(): Claimed__Params {
    return new Claimed__Params(this);
  }
}

export class Claimed__Params {
  _event: Claimed;

  constructor(event: Claimed) {
    this._event = event;
  }

  get claimer(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class MarketResolved extends ethereum.Event {
  get params(): MarketResolved__Params {
    return new MarketResolved__Params(this);
  }
}

export class MarketResolved__Params {
  _event: MarketResolved;

  constructor(event: MarketResolved) {
    this._event = event;
  }

  get winningOutcome(): i32 {
    return this._event.parameters[0].value.toI32();
  }

  get totalPayout(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class PredictionMarket__getMarketInfoResultInfoStruct extends ethereum.Tuple {
  get question(): string {
    return this[0].toString();
  }

  get category(): string {
    return this[1].toString();
  }

  get resolutionTime(): BigInt {
    return this[2].toBigInt();
  }

  get resolved(): boolean {
    return this[3].toBoolean();
  }

  get winningOutcome(): i32 {
    return this[4].toI32();
  }

  get totalYesShares(): BigInt {
    return this[5].toBigInt();
  }

  get totalNoShares(): BigInt {
    return this[6].toBigInt();
  }

  get totalPool(): BigInt {
    return this[7].toBigInt();
  }
}

export class PredictionMarket__getOddsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getYesOdds(): BigInt {
    return this.value0;
  }

  getNoOdds(): BigInt {
    return this.value1;
  }
}

export class PredictionMarket__getPositionResultPositionStruct extends ethereum.Tuple {
  get yesShares(): BigInt {
    return this[0].toBigInt();
  }

  get noShares(): BigInt {
    return this[1].toBigInt();
  }

  get claimed(): boolean {
    return this[2].toBoolean();
  }
}

export class PredictionMarket__getTotalBetsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getYesTotal(): BigInt {
    return this.value0;
  }

  getNoTotal(): BigInt {
    return this.value1;
  }
}

export class PredictionMarket extends ethereum.SmartContract {
  static bind(address: Address): PredictionMarket {
    return new PredictionMarket("PredictionMarket", address);
  }

  INITIAL_LIQUIDITY(): BigInt {
    let result = super.call(
      "INITIAL_LIQUIDITY",
      "INITIAL_LIQUIDITY():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_INITIAL_LIQUIDITY(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "INITIAL_LIQUIDITY",
      "INITIAL_LIQUIDITY():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MAX_POSITION(): BigInt {
    let result = super.call("MAX_POSITION", "MAX_POSITION():(uint256)", []);

    return result[0].toBigInt();
  }

  try_MAX_POSITION(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("MAX_POSITION", "MAX_POSITION():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  OUTCOME_NO(): i32 {
    let result = super.call("OUTCOME_NO", "OUTCOME_NO():(uint8)", []);

    return result[0].toI32();
  }

  try_OUTCOME_NO(): ethereum.CallResult<i32> {
    let result = super.tryCall("OUTCOME_NO", "OUTCOME_NO():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OUTCOME_YES(): i32 {
    let result = super.call("OUTCOME_YES", "OUTCOME_YES():(uint8)", []);

    return result[0].toI32();
  }

  try_OUTCOME_YES(): ethereum.CallResult<i32> {
    let result = super.tryCall("OUTCOME_YES", "OUTCOME_YES():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  PRECISION(): BigInt {
    let result = super.call("PRECISION", "PRECISION():(uint256)", []);

    return result[0].toBigInt();
  }

  try_PRECISION(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("PRECISION", "PRECISION():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  calculateShares(outcome: i32, amount: BigInt): BigInt {
    let result = super.call(
      "calculateShares",
      "calculateShares(uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(outcome)),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBigInt();
  }

  try_calculateShares(
    outcome: i32,
    amount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "calculateShares",
      "calculateShares(uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(outcome)),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  calculateWinnings(user: Address): BigInt {
    let result = super.call(
      "calculateWinnings",
      "calculateWinnings(address):(uint256)",
      [ethereum.Value.fromAddress(user)],
    );

    return result[0].toBigInt();
  }

  try_calculateWinnings(user: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "calculateWinnings",
      "calculateWinnings(address):(uint256)",
      [ethereum.Value.fromAddress(user)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  category(): string {
    let result = super.call("category", "category():(string)", []);

    return result[0].toString();
  }

  try_category(): ethereum.CallResult<string> {
    let result = super.tryCall("category", "category():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  factory(): Address {
    let result = super.call("factory", "factory():(address)", []);

    return result[0].toAddress();
  }

  try_factory(): ethereum.CallResult<Address> {
    let result = super.tryCall("factory", "factory():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getMarketInfo(): PredictionMarket__getMarketInfoResultInfoStruct {
    let result = super.call(
      "getMarketInfo",
      "getMarketInfo():((string,string,uint256,bool,uint8,uint256,uint256,uint256))",
      [],
    );

    return changetype<PredictionMarket__getMarketInfoResultInfoStruct>(
      result[0].toTuple(),
    );
  }

  try_getMarketInfo(): ethereum.CallResult<PredictionMarket__getMarketInfoResultInfoStruct> {
    let result = super.tryCall(
      "getMarketInfo",
      "getMarketInfo():((string,string,uint256,bool,uint8,uint256,uint256,uint256))",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<PredictionMarket__getMarketInfoResultInfoStruct>(
        value[0].toTuple(),
      ),
    );
  }

  getOdds(): PredictionMarket__getOddsResult {
    let result = super.call("getOdds", "getOdds():(uint256,uint256)", []);

    return new PredictionMarket__getOddsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
    );
  }

  try_getOdds(): ethereum.CallResult<PredictionMarket__getOddsResult> {
    let result = super.tryCall("getOdds", "getOdds():(uint256,uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PredictionMarket__getOddsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
      ),
    );
  }

  getPosition(
    user: Address,
  ): PredictionMarket__getPositionResultPositionStruct {
    let result = super.call(
      "getPosition",
      "getPosition(address):((uint256,uint256,bool))",
      [ethereum.Value.fromAddress(user)],
    );

    return changetype<PredictionMarket__getPositionResultPositionStruct>(
      result[0].toTuple(),
    );
  }

  try_getPosition(
    user: Address,
  ): ethereum.CallResult<PredictionMarket__getPositionResultPositionStruct> {
    let result = super.tryCall(
      "getPosition",
      "getPosition(address):((uint256,uint256,bool))",
      [ethereum.Value.fromAddress(user)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<PredictionMarket__getPositionResultPositionStruct>(
        value[0].toTuple(),
      ),
    );
  }

  getTotalBets(): PredictionMarket__getTotalBetsResult {
    let result = super.call(
      "getTotalBets",
      "getTotalBets():(uint256,uint256)",
      [],
    );

    return new PredictionMarket__getTotalBetsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
    );
  }

  try_getTotalBets(): ethereum.CallResult<PredictionMarket__getTotalBetsResult> {
    let result = super.tryCall(
      "getTotalBets",
      "getTotalBets():(uint256,uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PredictionMarket__getTotalBetsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
      ),
    );
  }

  question(): string {
    let result = super.call("question", "question():(string)", []);

    return result[0].toString();
  }

  try_question(): ethereum.CallResult<string> {
    let result = super.tryCall("question", "question():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  resolutionTime(): BigInt {
    let result = super.call("resolutionTime", "resolutionTime():(uint256)", []);

    return result[0].toBigInt();
  }

  try_resolutionTime(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "resolutionTime",
      "resolutionTime():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  resolved(): boolean {
    let result = super.call("resolved", "resolved():(bool)", []);

    return result[0].toBoolean();
  }

  try_resolved(): ethereum.CallResult<boolean> {
    let result = super.tryCall("resolved", "resolved():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  totalNoShares(): BigInt {
    let result = super.call("totalNoShares", "totalNoShares():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalNoShares(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalNoShares",
      "totalNoShares():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalPool(): BigInt {
    let result = super.call("totalPool", "totalPool():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalPool(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalPool", "totalPool():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalYesShares(): BigInt {
    let result = super.call("totalYesShares", "totalYesShares():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalYesShares(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalYesShares",
      "totalYesShares():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  winningOutcome(): i32 {
    let result = super.call("winningOutcome", "winningOutcome():(uint8)", []);

    return result[0].toI32();
  }

  try_winningOutcome(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "winningOutcome",
      "winningOutcome():(uint8)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _factory(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _question(): string {
    return this._call.inputValues[1].value.toString();
  }

  get _category(): string {
    return this._call.inputValues[2].value.toString();
  }

  get _resolutionTime(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ClaimWinningsCall extends ethereum.Call {
  get inputs(): ClaimWinningsCall__Inputs {
    return new ClaimWinningsCall__Inputs(this);
  }

  get outputs(): ClaimWinningsCall__Outputs {
    return new ClaimWinningsCall__Outputs(this);
  }
}

export class ClaimWinningsCall__Inputs {
  _call: ClaimWinningsCall;

  constructor(call: ClaimWinningsCall) {
    this._call = call;
  }
}

export class ClaimWinningsCall__Outputs {
  _call: ClaimWinningsCall;

  constructor(call: ClaimWinningsCall) {
    this._call = call;
  }
}

export class PlaceBetCall extends ethereum.Call {
  get inputs(): PlaceBetCall__Inputs {
    return new PlaceBetCall__Inputs(this);
  }

  get outputs(): PlaceBetCall__Outputs {
    return new PlaceBetCall__Outputs(this);
  }
}

export class PlaceBetCall__Inputs {
  _call: PlaceBetCall;

  constructor(call: PlaceBetCall) {
    this._call = call;
  }

  get outcome(): i32 {
    return this._call.inputValues[0].value.toI32();
  }
}

export class PlaceBetCall__Outputs {
  _call: PlaceBetCall;

  constructor(call: PlaceBetCall) {
    this._call = call;
  }
}

export class ResolveCall extends ethereum.Call {
  get inputs(): ResolveCall__Inputs {
    return new ResolveCall__Inputs(this);
  }

  get outputs(): ResolveCall__Outputs {
    return new ResolveCall__Outputs(this);
  }
}

export class ResolveCall__Inputs {
  _call: ResolveCall;

  constructor(call: ResolveCall) {
    this._call = call;
  }

  get _winningOutcome(): i32 {
    return this._call.inputValues[0].value.toI32();
  }
}

export class ResolveCall__Outputs {
  _call: ResolveCall;

  constructor(call: ResolveCall) {
    this._call = call;
  }
}
